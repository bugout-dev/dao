# Code generated by moonworm : https://github.com/bugout-dev/moonworm
# Moonworm version : 0.6.2

import argparse
import json
import os
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

from brownie import Contract, network, project
from brownie.network.contract import ContractContainer
from eth_typing.evm import ChecksumAddress


PROJECT_DIRECTORY = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
BUILD_DIRECTORY = os.path.join(PROJECT_DIRECTORY, "build", "contracts")


def boolean_argument_type(raw_value: str) -> bool:
    TRUE_VALUES = ["1", "t", "y", "true", "yes"]
    FALSE_VALUES = ["0", "f", "n", "false", "no"]

    if raw_value.lower() in TRUE_VALUES:
        return True
    elif raw_value.lower() in FALSE_VALUES:
        return False

    raise ValueError(
        f"Invalid boolean argument: {raw_value}. Value must be one of: {','.join(TRUE_VALUES + FALSE_VALUES)}"
    )


def bytes_argument_type(raw_value: str) -> str:
    return raw_value


def get_abi_json(abi_name: str) -> List[Dict[str, Any]]:
    abi_full_path = os.path.join(BUILD_DIRECTORY, f"{abi_name}.json")
    if not os.path.isfile(abi_full_path):
        raise IOError(
            f"File does not exist: {abi_full_path}. Maybe you have to compile the smart contracts?"
        )

    with open(abi_full_path, "r") as ifp:
        build = json.load(ifp)

    abi_json = build.get("abi")
    if abi_json is None:
        raise ValueError(f"Could not find ABI definition in: {abi_full_path}")

    return abi_json


def contract_from_build(abi_name: str) -> ContractContainer:
    # This is workaround because brownie currently doesn't support loading the same project multiple
    # times. This causes problems when using multiple contracts from the same project in the same
    # python project.
    PROJECT = project.main.Project("moonworm", Path(PROJECT_DIRECTORY))

    abi_full_path = os.path.join(BUILD_DIRECTORY, f"{abi_name}.json")
    if not os.path.isfile(abi_full_path):
        raise IOError(
            f"File does not exist: {abi_full_path}. Maybe you have to compile the smart contracts?"
        )

    with open(abi_full_path, "r") as ifp:
        build = json.load(ifp)

    return ContractContainer(PROJECT, build)


class TerminusFacet:
    def __init__(self, contract_address: Optional[ChecksumAddress]):
        self.contract_name = "TerminusFacet"
        self.address = contract_address
        self.contract = None
        self.abi = get_abi_json("TerminusFacet")
        if self.address is not None:
            self.contract: Optional[Contract] = Contract.from_abi(
                self.contract_name, self.address, self.abi
            )

    def deploy(self, transaction_config):
        contract_class = contract_from_build(self.contract_name)
        deployed_contract = contract_class.deploy(transaction_config)
        self.address = deployed_contract.address
        self.contract = deployed_contract
        return deployed_contract.tx

    def assert_contract_is_instantiated(self) -> None:
        if self.contract is None:
            raise Exception("contract has not been instantiated")

    def verify_contract(self):
        self.assert_contract_is_instantiated()
        contract_class = contract_from_build(self.contract_name)
        contract_class.publish_source(self.contract)

    def approve_for_pool(
        self, pool_id: int, operator: ChecksumAddress, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.approveForPool(pool_id, operator, transaction_config)

    def balance_of(
        self,
        account: ChecksumAddress,
        id: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.balanceOf.call(account, id, block_identifier=block_number)

    def balance_of_batch(
        self,
        accounts: List,
        ids: List,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.balanceOfBatch.call(
            accounts, ids, block_identifier=block_number
        )

    def burn(
        self, from_: ChecksumAddress, pool_id: int, amount: int, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.burn(from_, pool_id, amount, transaction_config)

    def contract_uri(self, block_number: Optional[Union[str, int]] = "latest") -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.contractURI.call(block_identifier=block_number)

    def create_pool_v1(
        self, _capacity: int, _transferable: bool, _burnable: bool, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.createPoolV1(
            _capacity, _transferable, _burnable, transaction_config
        )

    def create_pool_v2(
        self,
        _capacity: int,
        _transferable: bool,
        _burnable: bool,
        pool_uri: str,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.createPoolV2(
            _capacity, _transferable, _burnable, pool_uri, transaction_config
        )

    def create_simple_pool(self, _capacity: int, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.createSimplePool(_capacity, transaction_config)

    def is_approved_for_all(
        self,
        account: ChecksumAddress,
        operator: ChecksumAddress,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.isApprovedForAll.call(
            account, operator, block_identifier=block_number
        )

    def is_approved_for_pool(
        self,
        pool_id: int,
        operator: ChecksumAddress,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.isApprovedForPool.call(
            pool_id, operator, block_identifier=block_number
        )

    def mint(
        self,
        to: ChecksumAddress,
        pool_id: int,
        amount: int,
        data: bytes,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.mint(to, pool_id, amount, data, transaction_config)

    def mint_batch(
        self,
        to: ChecksumAddress,
        pool_i_ds: List,
        amounts: List,
        data: bytes,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.mintBatch(to, pool_i_ds, amounts, data, transaction_config)

    def payment_token(self, block_number: Optional[Union[str, int]] = "latest") -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.paymentToken.call(block_identifier=block_number)

    def pool_base_price(
        self, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.poolBasePrice.call(block_identifier=block_number)

    def pool_is_burnable(
        self, pool_id: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.poolIsBurnable.call(pool_id, block_identifier=block_number)

    def pool_is_transferable(
        self, pool_id: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.poolIsTransferable.call(
            pool_id, block_identifier=block_number
        )

    def pool_mint_batch(
        self, id: int, to_addresses: List, amounts: List, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.poolMintBatch(
            id, to_addresses, amounts, transaction_config
        )

    def safe_batch_transfer_from(
        self,
        from_: ChecksumAddress,
        to: ChecksumAddress,
        ids: List,
        amounts: List,
        data: bytes,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.safeBatchTransferFrom(
            from_, to, ids, amounts, data, transaction_config
        )

    def safe_transfer_from(
        self,
        from_: ChecksumAddress,
        to: ChecksumAddress,
        id: int,
        amount: int,
        data: bytes,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.safeTransferFrom(
            from_, to, id, amount, data, transaction_config
        )

    def set_approval_for_all(
        self, operator: ChecksumAddress, approved: bool, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setApprovalForAll(operator, approved, transaction_config)

    def set_contract_uri(self, _contract_uri: str, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setContractURI(_contract_uri, transaction_config)

    def set_controller(
        self, new_controller: ChecksumAddress, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setController(new_controller, transaction_config)

    def set_payment_token(
        self, new_payment_token: ChecksumAddress, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setPaymentToken(new_payment_token, transaction_config)

    def set_pool_base_price(self, new_base_price: int, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setPoolBasePrice(new_base_price, transaction_config)

    def set_pool_burnable(
        self, pool_id: int, burnable: bool, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setPoolBurnable(pool_id, burnable, transaction_config)

    def set_pool_controller(
        self, pool_id: int, new_controller: ChecksumAddress, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setPoolController(
            pool_id, new_controller, transaction_config
        )

    def set_pool_transferable(
        self, pool_id: int, transferable: bool, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setPoolTransferable(
            pool_id, transferable, transaction_config
        )

    def set_uri(self, pool_id: int, pool_uri: str, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.setURI(pool_id, pool_uri, transaction_config)

    def supports_interface(
        self, interface_id: bytes, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.supportsInterface.call(
            interface_id, block_identifier=block_number
        )

    def terminus_controller(
        self, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.terminusController.call(block_identifier=block_number)

    def terminus_pool_capacity(
        self, pool_id: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.terminusPoolCapacity.call(
            pool_id, block_identifier=block_number
        )

    def terminus_pool_controller(
        self, pool_id: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.terminusPoolController.call(
            pool_id, block_identifier=block_number
        )

    def terminus_pool_supply(
        self, pool_id: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.terminusPoolSupply.call(
            pool_id, block_identifier=block_number
        )

    def total_pools(self, block_number: Optional[Union[str, int]] = "latest") -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.totalPools.call(block_identifier=block_number)

    def unapprove_for_pool(
        self, pool_id: int, operator: ChecksumAddress, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.unapproveForPool(pool_id, operator, transaction_config)

    def uri(
        self, pool_id: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.uri.call(pool_id, block_identifier=block_number)

    def withdraw_payments(
        self, to_address: ChecksumAddress, amount: int, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.withdrawPayments(to_address, amount, transaction_config)


def get_transaction_config(args: argparse.Namespace) -> Dict[str, Any]:
    signer = network.accounts.load(args.sender, args.password)
    transaction_config: Dict[str, Any] = {"from": signer}
    if args.gas_price is not None:
        transaction_config["gas_price"] = args.gas_price
    if args.max_fee_per_gas is not None:
        transaction_config["max_fee"] = args.max_fee_per_gas
    if args.max_priority_fee_per_gas is not None:
        transaction_config["priority_fee"] = args.max_priority_fee_per_gas
    if args.confirmations is not None:
        transaction_config["required_confs"] = args.confirmations
    if args.nonce is not None:
        transaction_config["nonce"] = args.nonce
    return transaction_config


def add_default_arguments(parser: argparse.ArgumentParser, transact: bool) -> None:
    parser.add_argument(
        "--network", required=True, help="Name of brownie network to connect to"
    )
    parser.add_argument(
        "--address", required=False, help="Address of deployed contract to connect to"
    )
    if not transact:
        parser.add_argument(
            "--block-number",
            required=False,
            type=int,
            help="Call at the given block number, defaults to latest",
        )
        return
    parser.add_argument(
        "--sender", required=True, help="Path to keystore file for transaction sender"
    )
    parser.add_argument(
        "--password",
        required=False,
        help="Password to keystore file (if you do not provide it, you will be prompted for it)",
    )
    parser.add_argument(
        "--gas-price", default=None, help="Gas price at which to submit transaction"
    )
    parser.add_argument(
        "--max-fee-per-gas",
        default=None,
        help="Max fee per gas for EIP1559 transactions",
    )
    parser.add_argument(
        "--max-priority-fee-per-gas",
        default=None,
        help="Max priority fee per gas for EIP1559 transactions",
    )
    parser.add_argument(
        "--confirmations",
        type=int,
        default=None,
        help="Number of confirmations to await before considering a transaction completed",
    )
    parser.add_argument(
        "--nonce", type=int, default=None, help="Nonce for the transaction (optional)"
    )
    parser.add_argument(
        "--value", default=None, help="Value of the transaction in wei(optional)"
    )
    parser.add_argument("--verbose", action="store_true", help="Print verbose output")


def handle_deploy(args: argparse.Namespace) -> None:
    network.connect(args.network)
    transaction_config = get_transaction_config(args)
    contract = TerminusFacet(None)
    result = contract.deploy(transaction_config=transaction_config)
    print(result)
    if args.verbose:
        print(result.info())


def handle_verify_contract(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.verify_contract()
    print(result)


def handle_approve_for_pool(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.approve_for_pool(
        pool_id=args.pool_id,
        operator=args.operator,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_balance_of(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.balance_of(
        account=args.account, id=args.id, block_number=args.block_number
    )
    print(result)


def handle_balance_of_batch(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.balance_of_batch(
        accounts=args.accounts, ids=args.ids, block_number=args.block_number
    )
    print(result)


def handle_burn(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.burn(
        from_=args.from_arg,
        pool_id=args.pool_id,
        amount=args.amount,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_contract_uri(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.contract_uri(block_number=args.block_number)
    print(result)


def handle_create_pool_v1(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.create_pool_v1(
        _capacity=args.capacity_arg,
        _transferable=args.transferable_arg,
        _burnable=args.burnable_arg,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_create_pool_v2(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.create_pool_v2(
        _capacity=args.capacity_arg,
        _transferable=args.transferable_arg,
        _burnable=args.burnable_arg,
        pool_uri=args.pool_uri,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_create_simple_pool(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.create_simple_pool(
        _capacity=args.capacity_arg, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_is_approved_for_all(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.is_approved_for_all(
        account=args.account, operator=args.operator, block_number=args.block_number
    )
    print(result)


def handle_is_approved_for_pool(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.is_approved_for_pool(
        pool_id=args.pool_id, operator=args.operator, block_number=args.block_number
    )
    print(result)


def handle_mint(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.mint(
        to=args.to,
        pool_id=args.pool_id,
        amount=args.amount,
        data=args.data,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_mint_batch(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.mint_batch(
        to=args.to,
        pool_i_ds=args.pool_i_ds,
        amounts=args.amounts,
        data=args.data,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_payment_token(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.payment_token(block_number=args.block_number)
    print(result)


def handle_pool_base_price(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.pool_base_price(block_number=args.block_number)
    print(result)


def handle_pool_is_burnable(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.pool_is_burnable(
        pool_id=args.pool_id, block_number=args.block_number
    )
    print(result)


def handle_pool_is_transferable(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.pool_is_transferable(
        pool_id=args.pool_id, block_number=args.block_number
    )
    print(result)


def handle_pool_mint_batch(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.pool_mint_batch(
        id=args.id,
        to_addresses=args.to_addresses,
        amounts=args.amounts,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_safe_batch_transfer_from(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.safe_batch_transfer_from(
        from_=args.from_arg,
        to=args.to,
        ids=args.ids,
        amounts=args.amounts,
        data=args.data,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_safe_transfer_from(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.safe_transfer_from(
        from_=args.from_arg,
        to=args.to,
        id=args.id,
        amount=args.amount,
        data=args.data,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_approval_for_all(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_approval_for_all(
        operator=args.operator,
        approved=args.approved,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_contract_uri(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_contract_uri(
        _contract_uri=args.contract_uri_arg, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_controller(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_controller(
        new_controller=args.new_controller, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_payment_token(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_payment_token(
        new_payment_token=args.new_payment_token, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_pool_base_price(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_pool_base_price(
        new_base_price=args.new_base_price, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_pool_burnable(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_pool_burnable(
        pool_id=args.pool_id,
        burnable=args.burnable,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_pool_controller(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_pool_controller(
        pool_id=args.pool_id,
        new_controller=args.new_controller,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_pool_transferable(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_pool_transferable(
        pool_id=args.pool_id,
        transferable=args.transferable,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_set_uri(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.set_uri(
        pool_id=args.pool_id,
        pool_uri=args.pool_uri,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_supports_interface(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.supports_interface(
        interface_id=args.interface_id, block_number=args.block_number
    )
    print(result)


def handle_terminus_controller(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.terminus_controller(block_number=args.block_number)
    print(result)


def handle_terminus_pool_capacity(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.terminus_pool_capacity(
        pool_id=args.pool_id, block_number=args.block_number
    )
    print(result)


def handle_terminus_pool_controller(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.terminus_pool_controller(
        pool_id=args.pool_id, block_number=args.block_number
    )
    print(result)


def handle_terminus_pool_supply(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.terminus_pool_supply(
        pool_id=args.pool_id, block_number=args.block_number
    )
    print(result)


def handle_total_pools(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.total_pools(block_number=args.block_number)
    print(result)


def handle_unapprove_for_pool(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.unapprove_for_pool(
        pool_id=args.pool_id,
        operator=args.operator,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_uri(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    result = contract.uri(pool_id=args.pool_id, block_number=args.block_number)
    print(result)


def handle_withdraw_payments(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = TerminusFacet(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.withdraw_payments(
        to_address=args.to_address,
        amount=args.amount,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def generate_cli() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="CLI for TerminusFacet")
    parser.set_defaults(func=lambda _: parser.print_help())
    subcommands = parser.add_subparsers()

    deploy_parser = subcommands.add_parser("deploy")
    add_default_arguments(deploy_parser, True)
    deploy_parser.set_defaults(func=handle_deploy)

    verify_contract_parser = subcommands.add_parser("verify-contract")
    add_default_arguments(verify_contract_parser, False)
    verify_contract_parser.set_defaults(func=handle_verify_contract)

    approve_for_pool_parser = subcommands.add_parser("approve-for-pool")
    add_default_arguments(approve_for_pool_parser, True)
    approve_for_pool_parser.add_argument(
        "--pool-id", required=True, help="Type: uint256", type=int
    )
    approve_for_pool_parser.add_argument(
        "--operator", required=True, help="Type: address"
    )
    approve_for_pool_parser.set_defaults(func=handle_approve_for_pool)

    balance_of_parser = subcommands.add_parser("balance-of")
    add_default_arguments(balance_of_parser, False)
    balance_of_parser.add_argument("--account", required=True, help="Type: address")
    balance_of_parser.add_argument(
        "--id", required=True, help="Type: uint256", type=int
    )
    balance_of_parser.set_defaults(func=handle_balance_of)

    balance_of_batch_parser = subcommands.add_parser("balance-of-batch")
    add_default_arguments(balance_of_batch_parser, False)
    balance_of_batch_parser.add_argument(
        "--accounts", required=True, help="Type: address[]", nargs="+"
    )
    balance_of_batch_parser.add_argument(
        "--ids", required=True, help="Type: uint256[]", nargs="+"
    )
    balance_of_batch_parser.set_defaults(func=handle_balance_of_batch)

    burn_parser = subcommands.add_parser("burn")
    add_default_arguments(burn_parser, True)
    burn_parser.add_argument("--from-arg", required=True, help="Type: address")
    burn_parser.add_argument("--pool-id", required=True, help="Type: uint256", type=int)
    burn_parser.add_argument("--amount", required=True, help="Type: uint256", type=int)
    burn_parser.set_defaults(func=handle_burn)

    contract_uri_parser = subcommands.add_parser("contract-uri")
    add_default_arguments(contract_uri_parser, False)
    contract_uri_parser.set_defaults(func=handle_contract_uri)

    create_pool_v1_parser = subcommands.add_parser("create-pool-v1")
    add_default_arguments(create_pool_v1_parser, True)
    create_pool_v1_parser.add_argument(
        "--capacity-arg", required=True, help="Type: uint256", type=int
    )
    create_pool_v1_parser.add_argument(
        "--transferable-arg",
        required=True,
        help="Type: bool",
        type=boolean_argument_type,
    )
    create_pool_v1_parser.add_argument(
        "--burnable-arg", required=True, help="Type: bool", type=boolean_argument_type
    )
    create_pool_v1_parser.set_defaults(func=handle_create_pool_v1)

    create_pool_v2_parser = subcommands.add_parser("create-pool-v2")
    add_default_arguments(create_pool_v2_parser, True)
    create_pool_v2_parser.add_argument(
        "--capacity-arg", required=True, help="Type: uint256", type=int
    )
    create_pool_v2_parser.add_argument(
        "--transferable-arg",
        required=True,
        help="Type: bool",
        type=boolean_argument_type,
    )
    create_pool_v2_parser.add_argument(
        "--burnable-arg", required=True, help="Type: bool", type=boolean_argument_type
    )
    create_pool_v2_parser.add_argument(
        "--pool-uri", required=True, help="Type: string", type=str
    )
    create_pool_v2_parser.set_defaults(func=handle_create_pool_v2)

    create_simple_pool_parser = subcommands.add_parser("create-simple-pool")
    add_default_arguments(create_simple_pool_parser, True)
    create_simple_pool_parser.add_argument(
        "--capacity-arg", required=True, help="Type: uint256", type=int
    )
    create_simple_pool_parser.set_defaults(func=handle_create_simple_pool)

    is_approved_for_all_parser = subcommands.add_parser("is-approved-for-all")
    add_default_arguments(is_approved_for_all_parser, False)
    is_approved_for_all_parser.add_argument(
        "--account", required=True, help="Type: address"
    )
    is_approved_for_all_parser.add_argument(
        "--operator", required=True, help="Type: address"
    )
    is_approved_for_all_parser.set_defaults(func=handle_is_approved_for_all)

    is_approved_for_pool_parser = subcommands.add_parser("is-approved-for-pool")
    add_default_arguments(is_approved_for_pool_parser, False)
    is_approved_for_pool_parser.add_argument(
        "--pool-id", required=True, help="Type: uint256", type=int
    )
    is_approved_for_pool_parser.add_argument(
        "--operator", required=True, help="Type: address"
    )
    is_approved_for_pool_parser.set_defaults(func=handle_is_approved_for_pool)

    mint_parser = subcommands.add_parser("mint")
    add_default_arguments(mint_parser, True)
    mint_parser.add_argument("--to", required=True, help="Type: address")
    mint_parser.add_argument("--pool-id", required=True, help="Type: uint256", type=int)
    mint_parser.add_argument("--amount", required=True, help="Type: uint256", type=int)
    mint_parser.add_argument(
        "--data", required=True, help="Type: bytes", type=bytes_argument_type
    )
    mint_parser.set_defaults(func=handle_mint)

    mint_batch_parser = subcommands.add_parser("mint-batch")
    add_default_arguments(mint_batch_parser, True)
    mint_batch_parser.add_argument("--to", required=True, help="Type: address")
    mint_batch_parser.add_argument(
        "--pool-i-ds", required=True, help="Type: uint256[]", nargs="+"
    )
    mint_batch_parser.add_argument(
        "--amounts", required=True, help="Type: uint256[]", nargs="+"
    )
    mint_batch_parser.add_argument(
        "--data", required=True, help="Type: bytes", type=bytes_argument_type
    )
    mint_batch_parser.set_defaults(func=handle_mint_batch)

    payment_token_parser = subcommands.add_parser("payment-token")
    add_default_arguments(payment_token_parser, False)
    payment_token_parser.set_defaults(func=handle_payment_token)

    pool_base_price_parser = subcommands.add_parser("pool-base-price")
    add_default_arguments(pool_base_price_parser, False)
    pool_base_price_parser.set_defaults(func=handle_pool_base_price)

    pool_is_burnable_parser = subcommands.add_parser("pool-is-burnable")
    add_default_arguments(pool_is_burnable_parser, False)
    pool_is_burnable_parser.add_argument(
        "--pool-id", required=True, help="Type: uint256", type=int
    )
    pool_is_burnable_parser.set_defaults(func=handle_pool_is_burnable)

    pool_is_transferable_parser = subcommands.add_parser("pool-is-transferable")
    add_default_arguments(pool_is_transferable_parser, False)
    pool_is_transferable_parser.add_argument(
        "--pool-id", required=True, help="Type: uint256", type=int
    )
    pool_is_transferable_parser.set_defaults(func=handle_pool_is_transferable)

    pool_mint_batch_parser = subcommands.add_parser("pool-mint-batch")
    add_default_arguments(pool_mint_batch_parser, True)
    pool_mint_batch_parser.add_argument(
        "--id", required=True, help="Type: uint256", type=int
    )
    pool_mint_batch_parser.add_argument(
        "--to-addresses", required=True, help="Type: address[]", nargs="+"
    )
    pool_mint_batch_parser.add_argument(
        "--amounts", required=True, help="Type: uint256[]", nargs="+"
    )
    pool_mint_batch_parser.set_defaults(func=handle_pool_mint_batch)

    safe_batch_transfer_from_parser = subcommands.add_parser("safe-batch-transfer-from")
    add_default_arguments(safe_batch_transfer_from_parser, True)
    safe_batch_transfer_from_parser.add_argument(
        "--from-arg", required=True, help="Type: address"
    )
    safe_batch_transfer_from_parser.add_argument(
        "--to", required=True, help="Type: address"
    )
    safe_batch_transfer_from_parser.add_argument(
        "--ids", required=True, help="Type: uint256[]", nargs="+"
    )
    safe_batch_transfer_from_parser.add_argument(
        "--amounts", required=True, help="Type: uint256[]", nargs="+"
    )
    safe_batch_transfer_from_parser.add_argument(
        "--data", required=True, help="Type: bytes", type=bytes_argument_type
    )
    safe_batch_transfer_from_parser.set_defaults(func=handle_safe_batch_transfer_from)

    safe_transfer_from_parser = subcommands.add_parser("safe-transfer-from")
    add_default_arguments(safe_transfer_from_parser, True)
    safe_transfer_from_parser.add_argument(
        "--from-arg", required=True, help="Type: address"
    )
    safe_transfer_from_parser.add_argument("--to", required=True, help="Type: address")
    safe_transfer_from_parser.add_argument(
        "--id", required=True, help="Type: uint256", type=int
    )
    safe_transfer_from_parser.add_argument(
        "--amount", required=True, help="Type: uint256", type=int
    )
    safe_transfer_from_parser.add_argument(
        "--data", required=True, help="Type: bytes", type=bytes_argument_type
    )
    safe_transfer_from_parser.set_defaults(func=handle_safe_transfer_from)

    set_approval_for_all_parser = subcommands.add_parser("set-approval-for-all")
    add_default_arguments(set_approval_for_all_parser, True)
    set_approval_for_all_parser.add_argument(
        "--operator", required=True, help="Type: address"
    )
    set_approval_for_all_parser.add_argument(
        "--approved", required=True, help="Type: bool", type=boolean_argument_type
    )
    set_approval_for_all_parser.set_defaults(func=handle_set_approval_for_all)

    set_contract_uri_parser = subcommands.add_parser("set-contract-uri")
    add_default_arguments(set_contract_uri_parser, True)
    set_contract_uri_parser.add_argument(
        "--contract-uri-arg", required=True, help="Type: string", type=str
    )
    set_contract_uri_parser.set_defaults(func=handle_set_contract_uri)

    set_controller_parser = subcommands.add_parser("set-controller")
    add_default_arguments(set_controller_parser, True)
    set_controller_parser.add_argument(
        "--new-controller", required=True, help="Type: address"
    )
    set_controller_parser.set_defaults(func=handle_set_controller)

    set_payment_token_parser = subcommands.add_parser("set-payment-token")
    add_default_arguments(set_payment_token_parser, True)
    set_payment_token_parser.add_argument(
        "--new-payment-token", required=True, help="Type: address"
    )
    set_payment_token_parser.set_defaults(func=handle_set_payment_token)

    set_pool_base_price_parser = subcommands.add_parser("set-pool-base-price")
    add_default_arguments(set_pool_base_price_parser, True)
    set_pool_base_price_parser.add_argument(
        "--new-base-price", required=True, help="Type: uint256", type=int
    )
    set_pool_base_price_parser.set_defaults(func=handle_set_pool_base_price)

    set_pool_burnable_parser = subcommands.add_parser("set-pool-burnable")
    add_default_arguments(set_pool_burnable_parser, True)
    set_pool_burnable_parser.add_argument(
        "--pool-id", required=True, help="Type: uint256", type=int
    )
    set_pool_burnable_parser.add_argument(
        "--burnable", required=True, help="Type: bool", type=boolean_argument_type
    )
    set_pool_burnable_parser.set_defaults(func=handle_set_pool_burnable)

    set_pool_controller_parser = subcommands.add_parser("set-pool-controller")
    add_default_arguments(set_pool_controller_parser, True)
    set_pool_controller_parser.add_argument(
        "--pool-id", required=True, help="Type: uint256", type=int
    )
    set_pool_controller_parser.add_argument(
        "--new-controller", required=True, help="Type: address"
    )
    set_pool_controller_parser.set_defaults(func=handle_set_pool_controller)

    set_pool_transferable_parser = subcommands.add_parser("set-pool-transferable")
    add_default_arguments(set_pool_transferable_parser, True)
    set_pool_transferable_parser.add_argument(
        "--pool-id", required=True, help="Type: uint256", type=int
    )
    set_pool_transferable_parser.add_argument(
        "--transferable", required=True, help="Type: bool", type=boolean_argument_type
    )
    set_pool_transferable_parser.set_defaults(func=handle_set_pool_transferable)

    set_uri_parser = subcommands.add_parser("set-uri")
    add_default_arguments(set_uri_parser, True)
    set_uri_parser.add_argument(
        "--pool-id", required=True, help="Type: uint256", type=int
    )
    set_uri_parser.add_argument(
        "--pool-uri", required=True, help="Type: string", type=str
    )
    set_uri_parser.set_defaults(func=handle_set_uri)

    supports_interface_parser = subcommands.add_parser("supports-interface")
    add_default_arguments(supports_interface_parser, False)
    supports_interface_parser.add_argument(
        "--interface-id", required=True, help="Type: bytes4", type=bytes_argument_type
    )
    supports_interface_parser.set_defaults(func=handle_supports_interface)

    terminus_controller_parser = subcommands.add_parser("terminus-controller")
    add_default_arguments(terminus_controller_parser, False)
    terminus_controller_parser.set_defaults(func=handle_terminus_controller)

    terminus_pool_capacity_parser = subcommands.add_parser("terminus-pool-capacity")
    add_default_arguments(terminus_pool_capacity_parser, False)
    terminus_pool_capacity_parser.add_argument(
        "--pool-id", required=True, help="Type: uint256", type=int
    )
    terminus_pool_capacity_parser.set_defaults(func=handle_terminus_pool_capacity)

    terminus_pool_controller_parser = subcommands.add_parser("terminus-pool-controller")
    add_default_arguments(terminus_pool_controller_parser, False)
    terminus_pool_controller_parser.add_argument(
        "--pool-id", required=True, help="Type: uint256", type=int
    )
    terminus_pool_controller_parser.set_defaults(func=handle_terminus_pool_controller)

    terminus_pool_supply_parser = subcommands.add_parser("terminus-pool-supply")
    add_default_arguments(terminus_pool_supply_parser, False)
    terminus_pool_supply_parser.add_argument(
        "--pool-id", required=True, help="Type: uint256", type=int
    )
    terminus_pool_supply_parser.set_defaults(func=handle_terminus_pool_supply)

    total_pools_parser = subcommands.add_parser("total-pools")
    add_default_arguments(total_pools_parser, False)
    total_pools_parser.set_defaults(func=handle_total_pools)

    unapprove_for_pool_parser = subcommands.add_parser("unapprove-for-pool")
    add_default_arguments(unapprove_for_pool_parser, True)
    unapprove_for_pool_parser.add_argument(
        "--pool-id", required=True, help="Type: uint256", type=int
    )
    unapprove_for_pool_parser.add_argument(
        "--operator", required=True, help="Type: address"
    )
    unapprove_for_pool_parser.set_defaults(func=handle_unapprove_for_pool)

    uri_parser = subcommands.add_parser("uri")
    add_default_arguments(uri_parser, False)
    uri_parser.add_argument("--pool-id", required=True, help="Type: uint256", type=int)
    uri_parser.set_defaults(func=handle_uri)

    withdraw_payments_parser = subcommands.add_parser("withdraw-payments")
    add_default_arguments(withdraw_payments_parser, True)
    withdraw_payments_parser.add_argument(
        "--to-address", required=True, help="Type: address"
    )
    withdraw_payments_parser.add_argument(
        "--amount", required=True, help="Type: uint256", type=int
    )
    withdraw_payments_parser.set_defaults(func=handle_withdraw_payments)

    return parser


def main() -> None:
    parser = generate_cli()
    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
